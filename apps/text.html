<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Text Analysis Tool</title>
    <script src="https://unpkg.com/preact@10.15.1/dist/preact.min.js"></script>
    <script src="https://unpkg.com/preact@10.15.1/hooks/dist/hooks.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              gray: {
                50: "#faf9f7",
                100: "#f5f4f2",
                200: "#e6e4e0",
                300: "#d6d4ce",
                400: "#a8a59d",
                500: "#79766d",
                600: "#6d6a61",
                700: "#5a574e",
                800: "#48453c",
                900: "#32302a",
              },
            },
          },
        },
      };
    </script>
  </head>
  <body class="bg-gray-900 text-gray-200 min-h-screen">
    <div id="app"></div>

    <script type="module">
      const { h, render } = window.preact;
      const { useMemo, useState, useEffect, useRef } = window.preactHooks;

      // ========== CONSTANTS AND CONFIGURATION ==========
      const CONFIG = {
        CJK_RANGES: [
          [0x4e00, 0x9fff],
          [0x3400, 0x4dbf],
          [0x20000, 0x2a6df],
          [0x2a700, 0x2b73f],
          [0x2b740, 0x2b81f],
          [0x2b820, 0x2ceaf],
          [0x2ceb0, 0x2ebef],
          [0x3000, 0x303f],
          [0x3040, 0x309f],
          [0x30a0, 0x30ff],
          [0x31f0, 0x31ff],
          [0xff00, 0xffef],
          [0x1100, 0x11ff],
          [0x3130, 0x318f],
          [0xac00, 0xd7af],
        ],
        READING_SPEED_PRESETS: {
          cjk: { slow: 150, average: 250, fast: 350 },
          nonCjk: { slow: 120, average: 200, fast: 300 },
        },
        PUNCTUATION_PAUSES: {
          short: 0.3,
          medium: 0.5,
          long: 0.8,
        },
        MARKDOWN_SYMBOLS: /[#*_~`>=\-|\[\](){}]/g,
        SENTENCE_DELIMITERS: /[.!?。！？\n]+/,
        SYMBOL_CATEGORIES: {
          PUNCTUATION: /\p{P}/gu,
          SYMBOL: /\p{S}/gu,
          NUMBER: /\p{N}/gu,
          EMOJI: /\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu,
        },
        EMPTY_TEXT_RESPONSE: {
          wordCount: 0,
          charCountWithSpaces: 0,
          charCountWithoutSpaces: 0,
          paragraphCount: 0,
          sentenceCount: 0,
          readingTime: { minutes: 0, interpretation: "No content" },
          speakingTime: { minutes: 0, interpretation: "No content" },
          readability: { score: 0, grade: "N/A", interpretation: "No content" },
        },
      };

      // ========== PURE UTILITY FUNCTIONS ==========
      const isCJKChar = (char) => {
        const code = char.codePointAt(0);
        return CONFIG.CJK_RANGES.some(
          ([start, end]) => code >= start && code <= end
        );
      };

      const detectDominantLanguage = (text) => {
        if (!text.trim()) return "nonCjk";

        const chars = [...text];
        const cjkChars = chars.filter(isCJKChar).length;
        const totalNonWhitespace = chars.filter((c) => !/\s/.test(c)).length;

        return cjkChars / totalNonWhitespace > 0.3 ? "cjk" : "nonCjk";
      };

      const isCJKText = (text) => detectDominantLanguage(text) === "cjk";

      const countCharacters = (text, includeSpaces = true) =>
        includeSpaces ? text.length : text.replace(/\s/g, "").length;

      const countParagraphs = (text) =>
        text
          .split(/\n+/)
          .filter((paragraph) => paragraph.trim().length > 0).length;

      const removeMarkdown = (text) => text.replace(CONFIG.MARKDOWN_SYMBOLS, "");

      const countPunctuationByType = (text) => {
        const shortPause = (text.match(/[,，]/g) || []).length;
        const mediumPause = (text.match(/[;；:：]/g) || []).length;
        const longPause = (text.match(/[.!?。！？]/g) || []).length;

        return { short: shortPause, medium: mediumPause, long: longPause };
      };

      const calculateTimeEstimate = (
        wordCount,
        punctuationCounts,
        wordsPerMinute,
        timeLabels
      ) => {
        const baseMinutes = wordCount / wordsPerMinute;
        const pauseTime =
          (punctuationCounts.short * CONFIG.PUNCTUATION_PAUSES.short +
            punctuationCounts.medium * CONFIG.PUNCTUATION_PAUSES.medium +
            punctuationCounts.long * CONFIG.PUNCTUATION_PAUSES.long) /
          60;

        const totalMinutes = Math.max(0.1, baseMinutes + pauseTime);
        const interpretation =
          timeLabels.find(([threshold]) => totalMinutes < threshold)?.[1] ||
          timeLabels[timeLabels.length - 1][1];

        return {
          minutes: Math.ceil(totalMinutes * 10) / 10,
          interpretation,
          baseMinutes,
          pauseMinutes: pauseTime,
        };
      };

      // ========== TEXT PROCESSING FUNCTIONS ==========
      const countNonCJKWords = (text) => {
        const cleanedText = removeMarkdown(text).trim();
        if (!cleanedText) return 0;

        const words = cleanedText.split(/\s+/).filter((word) => {
          const cleanWord = word
            .replace(CONFIG.SYMBOL_CATEGORIES.PUNCTUATION, "")
            .replace(CONFIG.SYMBOL_CATEGORIES.SYMBOL, "");
          return cleanWord.length > 0;
        });

        return words.length;
      };

      const countCJKWords = (text) => {
        const cleanedText = removeMarkdown(text);
        if (!cleanedText.trim()) return 0;

        const chars = [...cleanedText];
        let count = 0;

        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];
          if (isCJKChar(char)) {
            count++;
          } else if (/\w/.test(char)) {
            while (i < chars.length - 1 && /\w/.test(chars[i + 1])) {
              i++;
            }
            count++;
          }
        }

        return count;
      };

      const countWords = (text) =>
        isCJKText(text) ? countCJKWords(text) : countNonCJKWords(text);

      const countNonCJKSyllables = (text) => {
        const trimmedText = text.trim();
        if (!trimmedText) return 0;

        const words = trimmedText.toLowerCase().split(/\s+/);
        return words.reduce((count, word) => {
          if (word.length <= 3) return count + 1;

          const vowelGroups = word.match(/[aeiouy]+/g);
          const syllableCount = vowelGroups ? vowelGroups.length : 1;

          return word.endsWith("e") && syllableCount > 1
            ? count + syllableCount - 1
            : count + syllableCount;
        }, 0);
      };

      const countSyllables = (text) =>
        isCJKText(text) ? countWords(text) : countNonCJKSyllables(text);

      // ========== SENTENCE SEGMENTATION ==========
      const segmentSentences = (text) => {
        const fullSentences = text
          .split(CONFIG.SENTENCE_DELIMITERS)
          .filter((s) => s.trim().length > 0)
          .map((s) => ({
            text: s.trim(),
            wordCount: countWords(s),
            charCount: countCharacters(s, false),
          }));

        const clauses = segmentClauses(text).filter((c) => c.wordCount > 0);

        return { fullSentences, clauses };
      };

      const segmentClauses = (text) => {
        const clauses = [];
        let currentClause = "";
        let inQuotes = false;
        let inParentheses = false;
        let quoteStack = [];

        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const nextChar = text[i + 1];

          // Handle quotes and parentheses
          if (char === '"' || char === "'" || char === "“" || char === "”") {
            inQuotes = !inQuotes;
            if (inQuotes) quoteStack.push(char);
            else quoteStack.pop();
          } else if (char === "(") {
            inParentheses = true;
          } else if (char === ")") {
            inParentheses = false;
          }

          // Only consider clause boundaries when not in quotes/parentheses
          if (!inQuotes && !inParentheses && quoteStack.length === 0) {
            const isClauseBoundary = isClauseBoundaryChar(char, nextChar, currentClause);

            if (isClauseBoundary && currentClause.trim()) {
              clauses.push({
                text: currentClause.trim(),
                wordCount: countWords(currentClause),
                charCount: countCharacters(currentClause, false),
              });
              currentClause = "";
            }
          }

          currentClause += char;
        }

        // Add the final clause
        if (currentClause.trim()) {
          clauses.push({
            text: currentClause.trim(),
            wordCount: countWords(currentClause),
            charCount: countCharacters(currentClause, false),
          });
        }

        return clauses;
      };

      const isClauseBoundaryChar = (char, nextChar, currentClause) => {
        const boundaryChars = [",", "，", ";", "；", ":", "："];
        const boundaryWords = [
          " and ",
          " but ",
          " or ",
          " yet ",
          " so ",
          " because ",
          " although ",
          " when ",
          " if ",
          " which ",
          " that ",
          " who ",
        ];

        if (boundaryChars.includes(char)) {
          return true;
        }

        const currentLower = currentClause.toLowerCase();
        return boundaryWords.some((word) => currentLower.endsWith(word));
      };

      // ========== TIME CALCULATION FUNCTIONS ==========
      const calculateReadingTime = (text, speedPreset = "average") => {
        const languageType = detectDominantLanguage(text);
        const wordCount = countWords(text);
        const punctuationCounts = countPunctuationByType(text);
        const wordsPerMinute = CONFIG.READING_SPEED_PRESETS[languageType][speedPreset];
        
        const timeLabels = [
          [1, "Quick read"],
          [5, "Short read"],
          [10, "Medium read"],
          [Infinity, "Long read"],
        ];

        return calculateTimeEstimate(wordCount, punctuationCounts, wordsPerMinute, timeLabels);
      };

      const calculateSpeakingTime = (text, speedPreset = "average") => {
        const languageType = detectDominantLanguage(text);
        const wordCount = countWords(text);
        const punctuationCounts = countPunctuationByType(text);
        const wordsPerMinute = CONFIG.READING_SPEED_PRESETS[languageType][speedPreset] * 0.75;
        
        const timeLabels = [
          [1, "Brief speech"],
          [3, "Short speech"],
          [7, "Medium speech"],
          [Infinity, "Extended speech"],
        ];

        return calculateTimeEstimate(wordCount, punctuationCounts, wordsPerMinute, timeLabels);
      };

      // ========== ANALYSIS FUNCTIONS ==========
      const countSentences = (text) => {
        const { fullSentences } = segmentSentences(text);
        return fullSentences.length;
      };

      const calculateReadability = (text) => {
        const words = countWords(text);
        const sentences = countSentences(text);
        const syllables = countSyllables(text);

        if (words === 0 || sentences === 0 || syllables === 0) {
          return {
            score: 0,
            grade: "N/A",
            interpretation: "No readable content",
          };
        }

        if (isCJKText(text)) {
          const avgSentenceLength = words / sentences;
          const score = Math.max(0, 100 - avgSentenceLength * 2);

          const readabilityRanges = [
            [80, "Very easy to read"],
            [60, "Easy to read"],
            [40, "Standard"],
            [20, "Fairly difficult"],
            [0, "Difficult"],
          ];

          const interpretation =
            readabilityRanges.find(([threshold]) => score >= threshold)?.[1] ||
            "Very difficult";

          return {
            score: Math.round(score),
            grade: "CJK Text",
            interpretation,
          };
        }

        // Flesch Reading Ease for non-CJK
        const score =
          206.835 - 1.015 * (words / sentences) - 84.6 * (syllables / words);

        const readabilityRanges = [
          [90, "5th grade", "Very easy to read"],
          [80, "6th grade", "Easy to read"],
          [70, "7th grade", "Fairly easy to read"],
          [60, "8th-9th grade", "Standard"],
          [50, "10th-12th grade", "Fairly difficult"],
          [30, "College", "Difficult"],
          [0, "College Graduate", "Very difficult"],
        ];

        const [grade, interpretation] = readabilityRanges
          .find(([threshold]) => score >= threshold)
          ?.slice(1) || ["N/A", "N/A"];

        return { score: Math.round(score), grade, interpretation };
      };

      const countWhitespace = (text) => {
        const whitespaceCount = (text.match(/\s/g) || []).length;
        const percentage = text.length
          ? Math.min(100, ((whitespaceCount / text.length) * 100).toFixed(1))
          : 0;

        return { count: whitespaceCount, percentage };
      };

      const countPunctuation = (text) => {
        const counts = countPunctuationByType(text);
        return counts.short + counts.medium + counts.long;
      };

      const countEmojis = (text) => {
        const emojiRegex = CONFIG.SYMBOL_CATEGORIES.EMOJI;
        const emojis = text.match(emojiRegex) || [];
        const uniqueEmojis = [...new Set(emojis)];

        return {
          count: emojis.length,
          unique: uniqueEmojis.length,
          list: uniqueEmojis.slice(0, 10),
        };
      };

      const countNumbersAndSymbols = (text) => {
        const numbers = (text.match(CONFIG.SYMBOL_CATEGORIES.NUMBER) || []).length;
        const symbols = (text.match(CONFIG.SYMBOL_CATEGORIES.SYMBOL) || []).length;
        return numbers + symbols;
      };

      const analyzeUnicodeScripts = (text) => {
        if (!text) return { distribution: [], primaryScript: "N/A" };

        const scripts = {
          Latin: 0,
          CJK: 0,
          Cyrillic: 0,
          Arabic: 0,
          Devanagari: 0,
          Other: 0,
        };

        for (const char of text) {
          if (/[a-zA-Z]/.test(char)) scripts.Latin++;
          else if (isCJKChar(char)) scripts.CJK++;
          else if (/[а-яА-Я]/.test(char)) scripts.Cyrillic++;
          else if (/[؀-ۿ]/.test(char)) scripts.Arabic++;
          else if (/[\u0900-\u097F]/.test(char)) scripts.Devanagari++;
          else if (char.trim() && !/\s/.test(char)) scripts.Other++;
        }

        const total = Object.values(scripts).reduce((sum, count) => sum + count, 0);
        const distribution = Object.entries(scripts)
          .filter(([_, count]) => count > 0)
          .map(([script, count]) => ({
            script,
            count,
            percentage: total ? ((count / total) * 100).toFixed(1) : 0,
          }))
          .sort((a, b) => b.count - a.count);

        const primaryScript = distribution[0]?.script || "N/A";

        return { distribution, primaryScript };
      };

      const analyzeWordLength = (text) => {
        if (isCJKText(text)) {
          return {
            average: "N/A",
            interpretation: "Not applicable for CJK text",
            distribution: [],
          };
        }

        const words = text.split(/\s+/).filter((word) => word.length > 0);
        const totalWords = words.length;

        if (totalWords === 0) {
          return { average: 0, interpretation: "No words", distribution: [] };
        }

        const totalLength = words.reduce((sum, word) => sum + word.length, 0);
        const average = totalLength / totalWords;

        const interpretations = [
          [4, "Short words"],
          [6, "Average words"],
          [8, "Long words"],
          [Infinity, "Very long words"],
        ];
        const interpretation = interpretations.find(([threshold]) => average < threshold)[1];

        const distributionRanges = {
          "1-3": (word) => word.length >= 1 && word.length <= 3,
          "4-6": (word) => word.length >= 4 && word.length <= 6,
          "7-9": (word) => word.length >= 7 && word.length <= 9,
          "10+": (word) => word.length >= 10,
        };

        const distribution = Object.entries(distributionRanges).map(
          ([range, condition]) => {
            const count = words.filter(condition).length;
            return {
              range,
              count,
              percentage: ((count / totalWords) * 100).toFixed(1),
            };
          }
        );

        return { average: average.toFixed(1), interpretation, distribution };
      };

      const calculateVocabularyDiversity = (text) => {
        if (isCJKText(text)) {
          return {
            percentage: "N/A",
            interpretation: "Not applicable for CJK text",
          };
        }

        const words = text
          .toLowerCase()
          .split(/\s+/)
          .filter((word) => word.length > 0);
        const uniqueWords = [...new Set(words)];
        const diversity = words.length
          ? (uniqueWords.length / words.length) * 100
          : 0;

        const diversityLevels = [
          [80, "Highly diverse vocabulary"],
          [60, "Good vocabulary diversity"],
          [40, "Moderate vocabulary diversity"],
          [0, "Limited vocabulary diversity"],
        ];

        const interpretation = diversityLevels.find(
          ([threshold]) => diversity >= threshold
        )[1];

        return { percentage: diversity.toFixed(1), interpretation };
      };

      const analyzeSentenceStructure = (text) => {
        const { fullSentences, clauses } = segmentSentences(text);
        const totalSentences = fullSentences.length;
        const totalClauses = clauses.length;

        if (totalSentences === 0) {
          return {
            averageLength: 0,
            interpretation: "No sentences",
            distribution: [],
            beginningVariety: { percentage: 0, assessment: "N/A" },
            clauseAnalysis: {
              averageLength: 0,
              interpretation: "No clauses",
              distribution: [],
            },
          };
        }

        // Full sentence analysis
        const totalWords = fullSentences.reduce(
          (sum, sentence) => sum + sentence.wordCount,
          0
        );
        const averageLength = totalWords / totalSentences;

        const lengthInterpretations = [
          [10, "Short sentences"],
          [20, "Medium sentences"],
          [Infinity, "Long sentences"],
        ];
        const interpretation = lengthInterpretations.find(
          ([threshold]) => averageLength < threshold
        )[1];

        const distributionCategories = {
          "Short (<10 words)": (sentence) => sentence.wordCount < 10,
          "Medium (10-20 words)": (sentence) =>
            sentence.wordCount >= 10 && sentence.wordCount <= 20,
          "Long (>20 words)": (sentence) => sentence.wordCount > 20,
        };

        const distribution = Object.entries(distributionCategories).map(
          ([category, condition]) => {
            const count = fullSentences.filter(condition).length;
            return {
              category,
              count,
              percentage: ((count / totalSentences) * 100).toFixed(1),
            };
          }
        );

        const beginnings = fullSentences.map((sentence) => {
          const firstWord = sentence.text.split(/\s+/)[0] || "";
          return firstWord.toLowerCase();
        });

        const uniqueBeginnings = [...new Set(beginnings)].length;
        const beginningVarietyPercentage =
          (uniqueBeginnings / totalSentences) * 100;

        const varietyAssessments = [
          [80, "Excellent variety"],
          [60, "Good variety"],
          [40, "Moderate variety"],
          [0, "Limited variety"],
        ];
        const beginningAssessment = varietyAssessments.find(
          ([threshold]) => beginningVarietyPercentage >= threshold
        )[1];

        // Clause analysis
        const clauseWords = clauses.reduce(
          (sum, clause) => sum + clause.wordCount,
          0
        );
        const avgClauseLength = clauseWords / totalClauses;

        const clauseLengthInterpretations = [
          [5, "Very concise"],
          [10, "Concise"],
          [15, "Moderate"],
          [Infinity, "Elaborated"],
        ];
        const clauseInterpretation = clauseLengthInterpretations.find(
          ([threshold]) => avgClauseLength < threshold
        )[1];

        const clauseDistributionCategories = {
          "Very short (<5 words)": (clause) => clause.wordCount < 5,
          "Short (5-10 words)": (clause) =>
            clause.wordCount >= 5 && clause.wordCount <= 10,
          "Medium (10-15 words)": (clause) =>
            clause.wordCount > 10 && clause.wordCount <= 15,
          "Long (>15 words)": (clause) => clause.wordCount > 15,
        };

        const clauseDistribution = Object.entries(
          clauseDistributionCategories
        ).map(([category, condition]) => {
          const count = clauses.filter(condition).length;
          return {
            category,
            count,
            percentage: ((count / totalClauses) * 100).toFixed(1),
          };
        });

        return {
          averageLength: averageLength.toFixed(1),
          interpretation,
          distribution,
          beginningVariety: {
            percentage: beginningVarietyPercentage.toFixed(1),
            assessment: beginningAssessment,
          },
          clauseAnalysis: {
            averageLength: avgClauseLength.toFixed(1),
            interpretation: clauseInterpretation,
            distribution: clauseDistribution,
            totalCount: totalClauses,
          },
        };
      };

      const analyzeParagraphStructure = (text) => {
        const paragraphs = text
          .split(/\n+/)
          .filter((p) => p.trim().length > 0);
        const totalParagraphs = paragraphs.length;

        if (totalParagraphs === 0) {
          return {
            avgSentences: 0,
            avgWords: 0,
            interpretation: "No paragraphs",
            distribution: [],
          };
        }

        const totalSentences = paragraphs.reduce(
          (sum, paragraph) => sum + countSentences(paragraph),
          0
        );
        const totalWords = paragraphs.reduce(
          (sum, paragraph) => sum + countWords(paragraph),
          0
        );

        const avgSentences = totalSentences / totalParagraphs;
        const avgWords = totalWords / totalParagraphs;

        const lengthInterpretations = [
          [50, "Short paragraphs"],
          [100, "Medium paragraphs"],
          [Infinity, "Long paragraphs"],
        ];
        const interpretation = lengthInterpretations.find(
          ([threshold]) => avgWords < threshold
        )[1];

        const distributionCategories = {
          "Short (<50 words)": (count) => count < 50,
          "Medium (50-100 words)": (count) => count >= 50 && count <= 100,
          "Long (>100 words)": (count) => count > 100,
        };

        const distribution = Object.entries(distributionCategories).map(
          ([category, condition]) => {
            const count = paragraphs.filter((paragraph) =>
              condition(countWords(paragraph))
            ).length;
            return {
              category,
              count,
              percentage: ((count / totalParagraphs) * 100).toFixed(1),
            };
          }
        );

        return {
          avgSentences: avgSentences.toFixed(1),
          avgWords: avgWords.toFixed(1),
          interpretation,
          distribution,
        };
      };

      const detectPrimaryLanguage = (text) =>
        isCJKText(text) ? "Chinese/Japanese/Korean" : "English/European";

      const analyzeMixedContent = (text) => {
        const { distribution } = analyzeUnicodeScripts(text);

        if (distribution.length <= 1) {
          return {
            assessment: "Monolingual content",
            details: "Text appears to be in a single language/script",
          };
        }

        const mixedPercentage = distribution
          .slice(1)
          .reduce((sum, item) => sum + parseFloat(item.percentage), 0);

        const mixedAssessments = [
          [10, "Mostly monolingual"],
          [30, "Slightly mixed"],
          [50, "Moderately mixed"],
          [Infinity, "Highly mixed content"],
        ];

        const assessment = mixedAssessments.find(
          ([threshold]) => mixedPercentage < threshold
        )[1];

        return {
          assessment,
          details: `Content contains ${mixedPercentage.toFixed(
            1
          )}% non-primary script`,
        };
      };

      const analyzeWordFrequency = (text) => {
        const words =
          text.toLowerCase().match(/\b[\w']+\b|[\u4e00-\u9fff]+/g) || [];
        const totalWords = words.length;

        if (totalWords === 0) {
          return { topWords: [], contentFocus: "No content" };
        }

        const frequency = {};
        words.forEach((word) => {
          if (
            !isCJKText(text) &&
            word.length <= 2 &&
            !isCJKChar(word)
          )
            return;
          frequency[word] = (frequency[word] || 0) + 1;
        });

        const topWords = Object.entries(frequency)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 8)
          .map(([word, count]) => ({
            word,
            count,
            percentage: ((count / totalWords) * 100).toFixed(1),
          }));

        const meaningfulWords = topWords
          .filter(
            (item) =>
              item.word.length > 3 || isCJKChar(item.word)
          )
          .slice(0, 5);

        const contentFocus =
          meaningfulWords.length > 0
            ? `Focus on: ${meaningfulWords
                .map((item) => item.word)
                .join(", ")}`
            : "General content";

        return { topWords, contentFocus };
      };

      // ========== COMPREHENSIVE TEXT ANALYSIS ==========
      const analyzeText = (text, speedPreset = "average") => {
        if (!text.trim()) {
          return {
            ...CONFIG.EMPTY_TEXT_RESPONSE,
            charCountWithSpaces: countCharacters(text, true),
            charCountWithoutSpaces: countCharacters(text, false),
            whitespace: countWhitespace(text),
            punctuation: countPunctuation(text),
            emojis: countEmojis(text),
            numbersSymbols: countNumbersAndSymbols(text),
            unicodeScripts: analyzeUnicodeScripts(text),
            wordLength: analyzeWordLength(text),
            vocabularyDiversity: calculateVocabularyDiversity(text),
            sentenceStructure: analyzeSentenceStructure(text),
            paragraphStructure: analyzeParagraphStructure(text),
            primaryLanguage: detectPrimaryLanguage(text),
            mixedContent: analyzeMixedContent(text),
            wordFrequency: analyzeWordFrequency(text),
            readingTime: calculateReadingTime(text, speedPreset),
            speakingTime: calculateSpeakingTime(text, speedPreset),
          };
        }

        const wordCount = countWords(text);

        return {
          wordCount,
          charCountWithSpaces: countCharacters(text, true),
          charCountWithoutSpaces: countCharacters(text, false),
          paragraphCount: countParagraphs(text),
          sentenceCount: countSentences(text),
          readingTime: calculateReadingTime(text, speedPreset),
          speakingTime: calculateSpeakingTime(text, speedPreset),
          readability: calculateReadability(text),
          whitespace: countWhitespace(text),
          punctuation: countPunctuation(text),
          emojis: countEmojis(text),
          numbersSymbols: countNumbersAndSymbols(text),
          unicodeScripts: analyzeUnicodeScripts(text),
          wordLength: analyzeWordLength(text),
          vocabularyDiversity: calculateVocabularyDiversity(text),
          sentenceStructure: analyzeSentenceStructure(text),
          paragraphStructure: analyzeParagraphStructure(text),
          primaryLanguage: detectPrimaryLanguage(text),
          mixedContent: analyzeMixedContent(text),
          wordFrequency: analyzeWordFrequency(text),
        };
      };

      // ========== REACT HOOKS ==========
      const useAutoResize = () => {
        const textareaRef = useRef(null);

        useEffect(() => {
          const textarea = textareaRef.current;
          if (!textarea) return;

          const resizeTextarea = () => {
            textarea.style.height = "auto";
            textarea.style.height = `${textarea.scrollHeight}px`;
          };

          resizeTextarea();

          let timeoutId;
          const handleInput = () => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(resizeTextarea, 100);
          };

          textarea.addEventListener("input", handleInput);
          return () => {
            clearTimeout(timeoutId);
            textarea.removeEventListener("input", handleInput);
          };
        }, []);

        return textareaRef;
      };

      // ========== UI COMPONENTS ==========
      const SpeedControl = ({ speedPreset, setSpeedPreset }) =>
        h("div", { class: "bg-gray-700 p-3 rounded mb-3" }, [
          h("div", { class: "text-gray-400 text-sm mb-2" }, "Reading Speed"),
          h("div", { class: "flex gap-2" }, [
            h(
              "button",
              {
                class: `px-3 py-1 rounded text-sm ${
                  speedPreset === "slow"
                    ? "bg-gray-600 text-gray-200"
                    : "bg-gray-800 text-gray-400 hover:bg-gray-700"
                }`,
                onClick: () => setSpeedPreset("slow"),
              },
              "Slow"
            ),
            h(
              "button",
              {
                class: `px-3 py-1 rounded text-sm ${
                  speedPreset === "average"
                    ? "bg-gray-600 text-gray-200"
                    : "bg-gray-800 text-gray-400 hover:bg-gray-700"
                }`,
                onClick: () => setSpeedPreset("average"),
              },
              "Medium"
            ),
            h(
              "button",
              {
                class: `px-3 py-1 rounded text-sm ${
                  speedPreset === "fast"
                    ? "bg-gray-600 text-gray-200"
                    : "bg-gray-800 text-gray-400 hover:bg-gray-700"
                }`,
                onClick: () => setSpeedPreset("fast"),
              },
              "Fast"
            ),
          ]),
        ]);

      const ReadabilityInfoModal = ({ isOpen, onClose }) => {
        if (!isOpen) return null;

        return h(
          "div",
          {
            class:
              "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50",
            onClick: onClose,
          },
          h(
            "div",
            {
              class:
                "bg-gray-800 rounded-lg p-6 max-w-2xl max-h-[80vh] overflow-y-auto",
              onClick: (e) => e.stopPropagation(),
            },
            [
              h("div", { class: "flex justify-between items-center mb-4" }, [
                h(
                  "h2",
                  { class: "text-xl font-semibold" },
                  "Flesch Reading Ease Score Explained"
                ),
                h(
                  "button",
                  {
                    class: "text-gray-400 hover:text-gray-200 text-2xl",
                    onClick: onClose,
                  },
                  "×"
                ),
              ]),
              h("div", { class: "space-y-4" }, [
                h("div", null, [
                  h("h3", { class: "font-medium mb-2" }, "Score Range: 0-100"),
                  h(
                    "p",
                    { class: "text-gray-300 text-sm" },
                    "Higher scores indicate easier reading. The score is calculated using:"
                  ),
                  h(
                    "div",
                    { class: "bg-gray-700 p-3 rounded mt-2 text-sm" },
                    "206.835 - 1.015 × (words/sentences) - 84.6 × (syllables/words)"
                  ),
                ]),
                h("div", null, [
                  h(
                    "h3",
                    { class: "font-medium mb-2" },
                    "Interpretation Guide"
                  ),
                  h("div", { class: "space-y-2" }, [
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "90-100:"),
                      h(
                        "span",
                        { class: "text-gray-300" },
                        "Very Easy (5th grade)"
                      ),
                    ]),
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "80-90:"),
                      h("span", { class: "text-gray-300" }, "Easy (6th grade)"),
                    ]),
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "70-80:"),
                      h(
                        "span",
                        { class: "text-gray-300" },
                        "Fairly Easy (7th grade)"
                      ),
                    ]),
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "60-70:"),
                      h(
                        "span",
                        { class: "text-gray-300" },
                        "Standard (8th-9th grade)"
                      ),
                    ]),
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "50-60:"),
                      h(
                        "span",
                        { class: "text-gray-300" },
                        "Fairly Difficult (10th-12th grade)"
                      ),
                    ]),
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "30-50:"),
                      h(
                        "span",
                        { class: "text-gray-300" },
                        "Difficult (College)"
                      ),
                    ]),
                    h("div", { class: "flex justify-between" }, [
                      h("span", null, "0-30:"),
                      h(
                        "span",
                        { class: "text-gray-300" },
                        "Very Difficult (College Graduate)"
                      ),
                    ]),
                  ]),
                ]),
                h("div", { class: "bg-gray-700 p-3 rounded text-sm" }, [
                  h(
                    "p",
                    { class: "text-gray-300" },
                    "Note: For CJK (Chinese/Japanese/Korean) texts, a simplified readability measure is used based on average sentence length."
                  ),
                ]),
              ]),
            ]
          )
        );
      };

      const TextInput = ({ text, setText, textareaRef }) =>
        h("div", { class: "bg-gray-800 rounded-lg p-4" }, [
          h("textarea", {
            ref: textareaRef,
            class:
              "w-full bg-gray-700 text-gray-200 rounded p-3 resize-none focus:outline-none focus:ring-2 focus:ring-gray-500",
            placeholder: "Enter your text here...",
            rows: 6,
            value: text,
            onInput: (e) => setText(e.target.value),
            "aria-label": "Text input for analysis",
          }),
        ]);

      const MetricCard = ({ title, value, subtitle = null, children = null }) =>
        h("div", { class: "bg-gray-700 p-3 rounded" }, [
          h("div", { class: "text-gray-400 text-sm" }, title),
          h("div", { class: "text-lg font-medium" }, value),
          subtitle && h("div", { class: "text-sm text-gray-400" }, subtitle),
          children,
        ]);

      const DistributionList = ({ items }) =>
        h(
          "div",
          { class: "bg-gray-700 p-3 rounded" },
          items.map((item) =>
            h("div", { class: "flex justify-between mb-1" }, [
              h(
                "span",
                null,
                item.label || item.script || item.range || item.category
              ),
              h("span", null, `${item.percentage}% (${item.count})`),
            ])
          )
        );

      const CoreMetrics = ({ analysis }) =>
        h("div", null, [
          h(
            "h2",
            {
              class:
                "text-xl font-semibold text-gray-200 mb-3 border-b border-gray-700 pb-2",
            },
            "Core Metrics"
          ),
          h("div", { class: "grid grid-cols-2 gap-3" }, [
            MetricCard({
              title:
                analysis.primaryLanguage === "Chinese/Japanese/Korean"
                  ? "Character Count"
                  : "Word Count",
              value: analysis.wordCount,
            }),
            MetricCard({
              title: "Character Count",
              value: `${analysis.charCountWithSpaces} (${analysis.charCountWithoutSpaces} no spaces)`,
            }),
            MetricCard({
              title: "Paragraph Count",
              value: analysis.paragraphCount,
            }),
            MetricCard({
              title: "Sentence Count",
              value: analysis.sentenceCount,
            }),
          ]),
        ]);

      const TimeEstimates = ({ analysis, speedPreset, setSpeedPreset }) =>
        h("div", null, [
          h(
            "h2",
            {
              class:
                "text-xl font-semibold text-gray-200 mb-3 border-b border-gray-700 pb-2",
            },
            "Time Estimates"
          ),
          h(SpeedControl, { speedPreset, setSpeedPreset }),
          h("div", { class: "grid grid-cols-2 gap-3" }, [
            MetricCard({
              title: "Reading Time",
              value: `${analysis.readingTime.minutes} min`,
              subtitle: analysis.readingTime.interpretation,
            }),
            MetricCard({
              title: "Speaking Time",
              value: `${analysis.speakingTime.minutes} min`,
              subtitle: analysis.speakingTime.interpretation,
            }),
          ]),
          h("div", { class: "mt-2 text-sm text-gray-400" }, [
            h("p", null, `Language: ${analysis.primaryLanguage}`),
            analysis.readingTime.pauseMinutes > 0 &&
              h(
                "p",
                null,
                `Includes ${analysis.readingTime.pauseMinutes.toFixed(
                  1
                )}min pause time`
              ),
          ]),
        ]);

      const ReadabilityAssessment = ({ analysis, onShowInfo }) =>
        analysis.readability.score > 0 &&
        h("div", null, [
          h("div", { class: "flex items-center gap-2 mb-3" }, [
            h(
              "h2",
              {
                class:
                  "text-xl font-semibold text-gray-200 border-b border-gray-700 pb-2 flex-1",
              },
              "Readability Assessment"
            ),
            h(
              "button",
              {
                class: "text-gray-400 hover:text-gray-200 text-lg",
                onClick: onShowInfo,
                title: "Learn about readability scores",
              },
              "ⓘ"
            ),
          ]),
          h("div", { class: "grid grid-cols-2 gap-3" }, [
            MetricCard({
              title: "Reading Ease Score",
              value: analysis.readability.score,
              subtitle: analysis.readability.interpretation,
            }),
            MetricCard({
              title: "Grade Level",
              value: analysis.readability.grade,
            }),
          ]),
        ]);

      const CharacterAnalysis = ({ analysis }) =>
        h("div", null, [
          h(
            "h2",
            {
              class:
                "text-xl font-semibold text-gray-200 mb-3 border-b border-gray-700 pb-2",
            },
            "Character Analysis"
          ),
          h(
            "div",
            { class: "grid grid-cols-2 gap-3" },
            [
              MetricCard({
                title: "Whitespace",
                value: `${analysis.whitespace.count} (${analysis.whitespace.percentage}%)`,
              }),
              MetricCard({ title: "Punctuation", value: analysis.punctuation }),
              analysis.emojis.count > 0 &&
                MetricCard({
                  title: "Emojis",
                  value: `${analysis.emojis.count} (${analysis.emojis.unique} unique)`,
                  children:
                    analysis.emojis.list.length > 0 &&
                    h(
                      "div",
                      { class: "text-sm text-gray-400 mt-1" },
                      analysis.emojis.list.join(" ")
                    ),
                }),
              MetricCard({
                title: "Numbers & Symbols",
                value: analysis.numbersSymbols,
              }),
            ].filter(Boolean)
          ),
          analysis.unicodeScripts.distribution.length > 0 &&
            h("div", { class: "mt-3" }, [
              h(
                "div",
                { class: "text-gray-400 text-sm mb-2" },
                "Unicode Script Distribution"
              ),
              DistributionList({ items: analysis.unicodeScripts.distribution }),
            ]),
        ]);

      const WordAnalysis = ({ analysis }) =>
        analysis.wordCount > 0 &&
        analysis.wordLength.interpretation !== "Not applicable for CJK text" &&
        h("div", null, [
          h(
            "h2",
            {
              class:
                "text-xl font-semibold text-gray-200 mb-3 border-b border-gray-700 pb-2",
            },
            "Word Analysis"
          ),
          h("div", { class: "grid grid-cols-2 gap-3" }, [
            MetricCard({
              title: "Average Word Length",
              value: `${analysis.wordLength.average} chars`,
              subtitle: analysis.wordLength.interpretation,
            }),
            MetricCard({
              title: "Vocabulary Diversity",
              value: `${analysis.vocabularyDiversity.percentage}%`,
              subtitle: analysis.vocabularyDiversity.interpretation,
            }),
          ]),
          analysis.wordLength.distribution.length > 0 &&
            h("div", { class: "mt-3" }, [
              h(
                "div",
                { class: "text-gray-400 text-sm mb-2" },
                "Word Length Distribution"
              ),
              DistributionList({
                items: analysis.wordLength.distribution.map((item) => ({
                  ...item,
                  label: `${item.range} chars`,
                })),
              }),
            ]),
        ]);

      const SentenceAnalysis = ({ analysis }) =>
        analysis.sentenceCount > 0 &&
        h("div", null, [
          h(
            "h2",
            {
              class:
                "text-xl font-semibold text-gray-200 mb-3 border-b border-gray-700 pb-2",
            },
            "Sentence Structure"
          ),
          h("div", { class: "grid grid-cols-2 gap-3" }, [
            MetricCard({
              title: "Average Sentence Length",
              value: `${analysis.sentenceStructure.averageLength} ${
                analysis.primaryLanguage === "Chinese/Japanese/Korean"
                  ? "chars"
                  : "words"
              }`,
              subtitle: analysis.sentenceStructure.interpretation,
            }),
            MetricCard({
              title: "Sentence Beginning Variety",
              value: `${analysis.sentenceStructure.beginningVariety.percentage}%`,
              subtitle: analysis.sentenceStructure.beginningVariety.assessment,
            }),
          ]),
          analysis.sentenceStructure.distribution.length > 0 &&
            h("div", { class: "mt-3" }, [
              h(
                "div",
                { class: "text-gray-400 text-sm mb-2" },
                "Sentence Length Distribution"
              ),
              DistributionList({
                items: analysis.sentenceStructure.distribution,
              }),
            ]),
          analysis.sentenceStructure.clauseAnalysis.totalCount > 0 &&
            h("div", { class: "mt-3" }, [
              h(
                "h3",
                { class: "text-lg font-medium text-gray-300 mb-2" },
                "Clause Analysis"
              ),
              h("div", { class: "grid grid-cols-2 gap-3 mb-3" }, [
                MetricCard({
                  title: "Total Clauses",
                  value: analysis.sentenceStructure.clauseAnalysis.totalCount,
                }),
                MetricCard({
                  title: "Average Length",
                  value: `${
                    analysis.sentenceStructure.clauseAnalysis.averageLength
                  } ${
                    analysis.primaryLanguage === "Chinese/Japanese/Korean"
                      ? "chars"
                      : "words"
                  }`,
                  subtitle:
                    analysis.sentenceStructure.clauseAnalysis.interpretation,
                }),
              ]),
              h(
                "div",
                { class: "text-gray-400 text-sm mb-2" },
                "Clause Length Distribution"
              ),
              DistributionList({
                items: analysis.sentenceStructure.clauseAnalysis.distribution,
              }),
            ]),
        ]);

      const AnalysisDisplay = ({
        analysis,
        speedPreset,
        setSpeedPreset,
        onShowReadabilityInfo,
      }) => {
        if (!analysis) {
          return h(
            "div",
            { class: "text-gray-400 text-center py-8" },
            h("p", null, "Analysis will appear here once you start typing")
          );
        }

        return h("div", { class: "space-y-6" }, [
          CoreMetrics({ analysis }),
          TimeEstimates({ analysis, speedPreset, setSpeedPreset }),
          ReadabilityAssessment({
            analysis,
            onShowInfo: onShowReadabilityInfo,
          }),
          CharacterAnalysis({ analysis }),
          WordAnalysis({ analysis }),
          SentenceAnalysis({ analysis }),
        ]);
      };

      // ========== MAIN APP COMPONENT ==========
      const App = () => {
        const [text, setText] = useState("");
        const [speedPreset, setSpeedPreset] = useState("average");
        const [showReadabilityInfo, setShowReadabilityInfo] = useState(false);
        const textareaRef = useAutoResize();

        const analysis = useMemo(
          () => analyzeText(text, speedPreset),
          [text, speedPreset]
        );

        return h("div", { class: "max-w-7xl mx-auto p-4" }, [
          h(ReadabilityInfoModal, {
            isOpen: showReadabilityInfo,
            onClose: () => setShowReadabilityInfo(false),
          }),
          h("div", { class: "grid grid-cols-1 lg:grid-cols-2 gap-6" }, [
            h(TextInput, { text, setText, textareaRef }),
            h(
              "div",
              {
                class:
                  "bg-gray-800 rounded-lg p-4 overflow-y-auto max-h-screen",
              },
              h(AnalysisDisplay, {
                analysis,
                speedPreset,
                setSpeedPreset,
                onShowReadabilityInfo: () => setShowReadabilityInfo(true),
              })
            ),
          ]),
        ]);
      };

      render(h(App), document.getElementById("app"));
    </script>
  </body>
</html>