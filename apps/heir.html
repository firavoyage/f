<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Heir</title>
    <style>
      /* 1. Define the specific colors from the original tailwind.config 
      */
      :root {
        --gray-100: #f5f4f2;
        --gray-500: #78716c;
        --gray-600: #57534e;
        --gray-700: #44403c;
        --gray-800: #292524;
        --gray-900: #1c1917;
      }

      /* 2. Global Resets and Body Styling 
      */
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        padding: 1rem;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background-color: var(--gray-900);
        color: var(--gray-100);
      }

      /* 3. Layout Container (max-w-4xl mx-auto)
      */
      .container {
        max-width: 56rem; /* 4xl */
        margin-left: auto;
        margin-right: auto;
      }

      /* 4. Button Toolbar (flex justify-end gap-2 mb-4)
      */
      .toolbar {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }

      /* 5. Button Styling 
         (px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition... focus...)
      */
      .btn {
        padding: 0.5rem 1rem;
        background-color: var(--gray-700);
        color: var(--gray-100);
        border: none;
        border-radius: 0.25rem;
        cursor: pointer;
        transition: background-color 200ms;
        font-size: 1rem;
      }

      .btn:hover {
        background-color: var(--gray-600);
      }

      .btn:focus {
        outline: none;
        box-shadow: 0 0 0 2px var(--gray-500);
      }

      /* 6. Textarea Styling
         (w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none)
      */
      textarea {
        width: 100%;
        height: 24rem; /* h-96 */
        padding: 1rem;
        background-color: var(--gray-800);
        color: var(--gray-100);
        border: 1px solid var(--gray-700);
        border-radius: 0.25rem;
        resize: none;
        font-family: inherit;
        font-size: 1rem;
      }

      textarea:focus {
        outline: none;
        /* The original had outline-none on focus, keeping that behavior */
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="toolbar">
        <button id="btn-decrease" class="btn">Decrease</button>
        <button id="btn-increase" class="btn">Increase</button>
      </div>
      <textarea
        id="editor"
        placeholder="Enter your markdown here..."
      ></textarea>
    </div>

    <script>
      // 1. Select DOM elements
      const textarea = document.getElementById("editor");
      const btnIncrease = document.getElementById("btn-increase");
      const btnDecrease = document.getElementById("btn-decrease");

      // 2. Logic Implementation
      // Copied directly from the React version, but adapted to read/write DOM nodes

      const increaseHeaders = () => {
        const markdown = textarea.value;
        const lines = markdown.split("\n");
        let inCodeBlock = false;

        const updatedLines = lines.map((line) => {
          // Toggle code block state
          if (line.trim().startsWith("```")) {
            inCodeBlock = !inCodeBlock;
            return line;
          }

          // Skip if we're in a code block
          if (inCodeBlock) return line;

          // Check if line is a header
          const headerMatch = line.match(/^(#{1,6})\s(.*)/);
          if (headerMatch) {
            const hashes = headerMatch[1];
            const content = headerMatch[2];

            // Only increase if we're not already at the maximum (h6)
            if (hashes.length < 6) {
              return "#" + hashes + " " + content;
            }
          }

          return line;
        });

        const newMarkdown = updatedLines.join("\n");
        textarea.value = newMarkdown;

        handleClipboard(newMarkdown, btnIncrease, "Increase");
      };

      const decreaseHeaders = () => {
        const markdown = textarea.value;
        const lines = markdown.split("\n");
        let inCodeBlock = false;

        const updatedLines = lines.map((line) => {
          // Toggle code block state
          if (line.trim().startsWith("```")) {
            inCodeBlock = !inCodeBlock;
            return line;
          }

          // Skip if we're in a code block
          if (inCodeBlock) return line;

          // Check if line is a header
          const headerMatch = line.match(/^(#{1,6})\s(.*)/);
          if (headerMatch) {
            const hashes = headerMatch[1];
            const content = headerMatch[2];

            // Remove one # or remove header entirely if it's only one #
            if (hashes.length === 1) {
              return content; // Remove header completely
            } else {
              return hashes.slice(1) + " " + content; // Remove one #
            }
          }

          return line;
        });

        const newMarkdown = updatedLines.join("\n");
        textarea.value = newMarkdown;

        handleClipboard(newMarkdown, btnDecrease, "Decrease");
      };

      // Helper to handle clipboard and button text state
      const handleClipboard = (text, buttonElement, originalText) => {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            buttonElement.innerText = "Copied!";
            setTimeout(() => (buttonElement.innerText = originalText), 2000);
          })
          .catch((err) => {
            buttonElement.innerText = "Copy Failed";
            setTimeout(() => (buttonElement.innerText = originalText), 2000);
          });
      };

      // 3. Event Listeners
      btnIncrease.addEventListener("click", increaseHeaders);
      btnDecrease.addEventListener("click", decreaseHeaders);

      // 4. Focus Management logic (Replicating the original useEffect)
      const handleFocus = () => {
        if (textarea) {
          textarea.focus();
        }
      };

      // Initial focus
      handleFocus();

      // Focus on click anywhere
      // Note: This matches the aggressive focus behavior of the original
      document.addEventListener("click", (e) => {
        // We only explicitly focus if the click didn't originate from the textarea itself
        // to prevent potential selection interference, though the original just called focus().
        handleFocus();
      });
    </script>
  </body>
</html>
