write a js fn.

- use const arrow fn. write jsdoc with examples.
- name: merge
- param: target, source
- returns cup of both as a new object, dont modify target and source
- if target and source have a same key and both are object, merge recursively
- if target and source have a same key and either isnt object, keep target
- handle recursion with loop

---

Here's the implementation of the `merge` function using a loop-based approach to handle recursion, along with JSDoc and examples:

```javascript
/**
 * Merges two objects recursively, creating a new object without modifying the originals.
 * If both values for a key are objects, they are merged recursively.
 * If either value is not an object, the target's value is kept.
 *
 * @param {Object} target - The target object to merge into.
 * @param {Object} source - The source object to merge from.
 * @returns {Object} A new merged object.
 *
 * @example
 * // Basic merge
 * merge({ a: 1 }, { b: 2 });
 * // Returns: { a: 1, b: 2 }
 *
 * @example
 * // Recursive merge with objects
 * merge(
 *   { a: 1, b: { c: 2 } },
 *   { b: { d: 3 }, e: 4 }
 * );
 * // Returns: { a: 1, b: { c: 2, d: 3 }, e: 4 }
 *
 * @example
 * // Conflict: source value is not an object
 * merge(
 *   { a: { b: 2 } },
 *   { a: 5 }
 * );
 * // Returns: { a: { b: 2 } }
 *
 * @example
 * // Conflict: target value is not an object
 * merge(
 *   { a: 5 },
 *   { a: { b: 2 } }
 * );
 * // Returns: { a: 5 }
 */
const merge = (target, source) => {
  // Handle non-object targets or sources
  if (typeof target !== "object" || target === null) return target;
  if (typeof source !== "object" || source === null) return { ...target };

  const result = { ...target };
  const stack = [{ result, source }];

  while (stack.length > 0) {
    const { result: currentResult, source: currentSource } = stack.pop();

    for (const key of Object.keys(currentSource)) {
      if (key in currentResult) {
        const targetVal = currentResult[key];
        const sourceVal = currentSource[key];

        if (
          typeof targetVal === "object" &&
          targetVal !== null &&
          typeof sourceVal === "object" &&
          sourceVal !== null
        ) {
          // Both are objects, merge recursively
          currentResult[key] = { ...targetVal };
          stack.push({
            result: currentResult[key],
            source: sourceVal,
          });
        }
        // Else: keep target value (no action needed)
      } else {
        // New key, copy from source (deep copy if object)
        currentResult[key] =
          typeof sourceVal === "object" && sourceVal !== null
            ? { ...sourceVal }
            : sourceVal;
      }
    }
  }

  return result;
};
```

### Key Features:

1. **Loop-based Recursion**: Uses a stack to handle nested objects iteratively.
2. **Immutable**: Doesn't modify original objects (`target` or `source`).
3. **Conflict Handling**:
   - Keeps `target`'s value if there's a conflict and either value isn't an object.
   - Merges recursively if both values are objects.
4. **Deep Copy**: Ensures all nested objects are copied rather than referenced.

### Examples:

- Simple properties are merged.
- Nested objects are recursively merged.
- Conflicts where either value isn't an object resolve to the `target`'s value.
