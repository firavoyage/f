write a js fn.

- use const arrow fn. write jsdoc with examples.
- name: same
- params: a, b
- if a and b are both objects, deeply compare them.
- returns true if they are the same, otherwise false.
- use loop instead of recursion

---

Here's a JavaScript function that meets your requirements:

```javascript
/**
 * Deeply compares two values for equality without using recursion.
 * Handles objects and arrays by using iterative depth-first traversal.
 *
 * @param {*} a - The first value to compare
 * @param {*} b - The second value to compare
 * @returns {boolean} True if the values are deeply equal, false otherwise
 *
 * @example
 * // Primitives
 * same(1, 1); // true
 * same('hello', 'hello'); // true
 * same(1, '1'); // false
 *
 * @example
 * // Arrays
 * same([1, 2, 3], [1, 2, 3]); // true
 * same([1, 2, 3], [1, 2, 4]); // false
 *
 * @example
 * // Objects
 * same({ a: 1, b: 2 }, { a: 1, b: 2 }); // true
 * same({ a: 1, b: 2 }, { b: 2, a: 1 }); // true (order doesn't matter)
 * same({ a: 1, b: 2 }, { a: 1, b: 3 }); // false
 *
 * @example
 * // Nested structures
 * same({ a: [1, { b: 2 }] }, { a: [1, { b: 2 }] }); // true
 * same({ a: [1, { b: 2 }] }, { a: [1, { b: 3 }] }); // false
 */
const same = (a, b) => {
  // Quick reference equality check
  if (a === b) return true;

  // If either is null or not an object, do strict equality check
  if (
    a === null ||
    b === null ||
    typeof a !== "object" ||
    typeof b !== "object"
  ) {
    return a === b;
  }

  // Check if both are arrays or both are objects
  if (Array.isArray(a) !== Array.isArray(b)) {
    return false;
  }

  // Stack for iterative depth-first traversal
  const stack = [{ a, b }];

  while (stack.length > 0) {
    const { a: currentA, b: currentB } = stack.pop();

    // Quick reference check for current level
    if (currentA === currentB) continue;

    // Type check for current level
    if (
      typeof currentA !== "object" ||
      typeof currentB !== "object" ||
      currentA === null ||
      currentB === null ||
      Array.isArray(currentA) !== Array.isArray(currentB)
    ) {
      return false;
    }

    const keysA = Object.keys(currentA);
    const keysB = Object.keys(currentB);

    // Check if number of keys match
    if (keysA.length !== keysB.length) {
      return false;
    }

    // Check if all keys in A exist in B
    for (const key of keysA) {
      if (!currentB.hasOwnProperty(key)) {
        return false;
      }

      const valueA = currentA[key];
      const valueB = currentB[key];

      // Quick reference equality for values
      if (valueA === valueB) continue;

      // If values are objects, add to stack for further comparison
      if (
        typeof valueA === "object" &&
        valueA !== null &&
        typeof valueB === "object" &&
        valueB !== null
      ) {
        stack.push({ a: valueA, b: valueB });
      } else if (valueA !== valueB) {
        // Primitive values don't match
        return false;
      }
    }
  }

  return true;
};
```

This function:

- Uses `const` arrow function syntax as requested
- Includes comprehensive JSDoc with examples
- Deeply compares objects and arrays without recursion
- Handles nested structures using iterative depth-first traversal with a stack
- Considers object key order independence
- Includes early termination for performance optimization
- Handles primitive values, arrays, and objects correctly

The iterative approach uses a stack to simulate recursion, making it suitable for deeply nested structures without risking stack overflow.
