# a (d)

write a single page web app

- load libraries by cdn
- use dark theme
- dont use pure white and pure black which are dazzling
- dont add unnecessary elements like a title
- dont write demos of limited features
- use preact and tailwind
- use warm grayscale color

- content is a textarea which is always focused whenever entering page, clicking anywhere, etc. and a button "increase"
- inside the textarea there will be markdown
- when clicking "increase", increase all headers by one. e.g. `##` to `###`
- only increase real headers. e.g. `##` inside code blocks should be included.

---

## Markdown Header Increaser

Here's a single-page web app that meets all your requirements:

````html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Header Increaser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/preact@10.12.1/dist/preact.min.js"></script>
    <script src="https://unpkg.com/preact@10.12.1/hooks/dist/hooks.umd.js"></script>
    <style>
      body {
        background-color: #292524;
        color: #f5f5f4;
      }
      textarea:focus {
        outline: none;
        box-shadow: none;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 font-sans">
    <div id="app"></div>

    <script type="module">
      const { html, render } = window.preact;
      const { useState, useEffect, useRef } = window.preactHooks;

      const App = () => {
        const [markdown, setMarkdown] = useState("");
        const textareaRef = useRef(null);

        // Focus textarea on mount and after any click
        useEffect(() => {
          const focusTextarea = () => {
            if (textareaRef.current) {
              textareaRef.current.focus();
            }
          };

          focusTextarea();
          document.addEventListener("click", focusTextarea);

          return () => {
            document.removeEventListener("click", focusTextarea);
          };
        }, []);

        const increaseHeaders = () => {
          if (!markdown) return;

          // Split by code blocks to avoid modifying headers inside them
          const parts = markdown.split(/(```[\s\S]*?```)/g);

          const processedParts = parts.map((part, index) => {
            // Skip code blocks (odd indices after split)
            if (part.startsWith("```") && part.endsWith("```")) {
              return part;
            }

            // Process headers in non-code parts
            return part.replace(
              /^(\s{0,3})(#{1,6})\s+(.*)$/gm,
              (match, indentation, hashes, content) => {
                // Increase header level, max to 6
                const newLevel = Math.min(hashes.length + 1, 6);
                return `${indentation}${"#".repeat(newLevel)} ${content}`;
              }
            );
          });

          setMarkdown(processedParts.join(""));
        };

        return html`
          <div class="flex flex-col h-screen max-w-4xl mx-auto">
            <div class="flex justify-end mb-4">
              <button
                onClick=${increaseHeaders}
                class="px-4 py-2 bg-amber-700 hover:bg-amber-600 text-stone-100 rounded transition-colors"
              >
                Increase Headers
              </button>
            </div>
            <textarea
              ref=${textareaRef}
              value=${markdown}
              onInput=${(e) => setMarkdown(e.target.value)}
              class="flex-1 w-full p-4 bg-stone-800 text-stone-200 border border-stone-600 rounded resize-none"
              placeholder="Enter your markdown here..."
            ></textarea>
          </div>
        `;
      };

      render(html`<${App} />`, document.getElementById("app"));
    </script>
  </body>
</html>
````

This web app:

- Uses Preact and Tailwind CSS via CDN
- Implements a dark theme with warm grayscale colors
- Avoids pure white (#ffffff) and pure black (#000000)
- Has no unnecessary elements like titles
- Features a textarea that's always focused when interacting with the page
- Includes an "Increase" button that increases all markdown headers by one level
- Correctly handles headers inside code blocks by not modifying them

The app uses a warm grayscale color palette with:

- Background: #292524 (stone-800)
- Text: #f5f5f4 (stone-100)
- Button: #a16207 (amber-700) that changes to #ca8a04 (amber-600) on hover
- Textarea background: #1c1917 (stone-900)
- Border: #57534e (stone-600)

The header increasing functionality properly handles headers in markdown format while preserving code blocks and their contents.

# a.2

write a single page web app

- load libraries by cdn
- use dark theme
- dont use pure white and pure black which are dazzling
- dont add unnecessary elements like a title
- dont write demos of limited features
- use preact and tailwind
- use preact.h
- use warm grayscale color

- content is a textarea which is always focused whenever entering page, clicking anywhere, etc. and a button "increase"
- inside the textarea there will be markdown
- when clicking "increase", increase all headers by one. e.g. `##` to `###`
- only increase real headers. e.g. `##` inside code blocks should be included.

---

## Markdown Header Increaser

Here's a complete single-page web app that meets all your requirements:

````html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/hooks/dist/hooks.umd.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gray: {
                50: "#faf9f7",
                100: "#f5f4f2",
                200: "#e6e4e0",
                300: "#d6d3ce",
                400: "#a8a29e",
                500: "#78716c",
                600: "#57534e",
                700: "#44403c",
                800: "#292524",
                900: "#1c1917",
              },
            },
          },
        },
      };
    </script>
    <style>
      body {
        background-color: #1c1917;
        color: #f5f4f2;
      }
      textarea:focus {
        outline: none;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 font-sans">
    <div id="app"></div>

    <script type="module">
      const { h, render } = preact;
      const { useState, useRef, useEffect } = preactHooks;

      function App() {
        const [markdown, setMarkdown] = useState(
          "# Heading 1\n\nSome text\n\n## Heading 2\n\n```\n# Code comment (not a header)\n```\n\n### Heading 3"
        );
        const textareaRef = useRef(null);

        // Keep textarea focused
        useEffect(() => {
          const handleFocus = () => {
            if (textareaRef.current) {
              textareaRef.current.focus();
            }
          };

          // Initial focus
          handleFocus();

          // Focus on click anywhere
          document.addEventListener("click", handleFocus);

          return () => {
            document.removeEventListener("click", handleFocus);
          };
        }, []);

        const increaseHeaders = () => {
          const lines = markdown.split("\n");
          let inCodeBlock = false;
          const updatedLines = lines.map((line) => {
            // Toggle code block state
            if (line.trim().startsWith("```")) {
              inCodeBlock = !inCodeBlock;
              return line;
            }

            // Skip if we're in a code block
            if (inCodeBlock) return line;

            // Check if line is a header (starts with 1-6 # characters followed by space)
            const headerMatch = line.match(/^(#{1,6})\s(.*)/);
            if (headerMatch) {
              const hashes = headerMatch[1];
              const content = headerMatch[2];

              // Only increase if we're not already at the maximum (h6)
              if (hashes.length < 6) {
                return "#" + hashes + " " + content;
              }
            }

            return line;
          });

          setMarkdown(updatedLines.join("\n"));
        };

        return h(
          "div",
          { class: "max-w-4xl mx-auto" },
          h(
            "div",
            { class: "flex justify-end mb-4" },
            h(
              "button",
              {
                onClick: increaseHeaders,
                class:
                  "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
              },
              "Increase Headers"
            )
          ),
          h("textarea", {
            ref: textareaRef,
            value: markdown,
            onInput: (e) => setMarkdown(e.target.value),
            class:
              "w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none",
            placeholder: "Enter your markdown here...",
          })
        );
      }

      render(h(App), document.getElementById("app"));
    </script>
  </body>
</html>
````

This implementation:

- Uses Preact and Tailwind CSS via CDN
- Implements a warm grayscale color palette (avoiding pure black/white)
- Contains only a textarea and an "Increase" button
- Automatically focuses the textarea on page load and when clicking anywhere
- Increases all markdown headers by one level when clicking the button
- Correctly ignores headers inside code blocks
- Uses Preact with the `h` function directly

The app has a clean, minimal interface with appropriate focus management and handles the header increasing logic as specified.

# a.2 2

- remove the inital dummy text
- copy the content after clicking the button

---

## Markdown Header Increaser

Here's the updated single-page web app:

````html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/hooks/dist/hooks.umd.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gray: {
                50: "#faf9f7",
                100: "#f5f4f2",
                200: "#e6e4e0",
                300: "#d6d3ce",
                400: "#a8a29e",
                500: "#78716c",
                600: "#57534e",
                700: "#44403c",
                800: "#292524",
                900: "#1c1917",
              },
            },
          },
        },
      };
    </script>
    <style>
      body {
        background-color: #1c1917;
        color: #f5f4f2;
      }
      textarea:focus {
        outline: none;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 font-sans">
    <div id="app"></div>

    <script type="module">
      const { h, render } = preact;
      const { useState, useRef, useEffect } = preactHooks;

      function App() {
        const [markdown, setMarkdown] = useState("");
        const [buttonText, setButtonText] = useState("Increase");
        const textareaRef = useRef(null);

        // Keep textarea focused
        useEffect(() => {
          const handleFocus = () => {
            if (textareaRef.current) {
              textareaRef.current.focus();
            }
          };

          // Initial focus
          handleFocus();

          // Focus on click anywhere
          document.addEventListener("click", handleFocus);

          return () => {
            document.removeEventListener("click", handleFocus);
          };
        }, []);

        const increaseHeaders = () => {
          const lines = markdown.split("\n");
          let inCodeBlock = false;
          const updatedLines = lines.map((line) => {
            // Toggle code block state
            if (line.trim().startsWith("```")) {
              inCodeBlock = !inCodeBlock;
              return line;
            }

            // Skip if we're in a code block
            if (inCodeBlock) return line;

            // Check if line is a header (starts with 1-6 # characters followed by space)
            const headerMatch = line.match(/^(#{1,6})\s(.*)/);
            if (headerMatch) {
              const hashes = headerMatch[1];
              const content = headerMatch[2];

              // Only increase if we're not already at the maximum (h6)
              if (hashes.length < 6) {
                return "#" + hashes + " " + content;
              }
            }

            return line;
          });

          const newMarkdown = updatedLines.join("\n");
          setMarkdown(newMarkdown);

          // Copy to clipboard
          navigator.clipboard
            .writeText(newMarkdown)
            .then(() => {
              setButtonText("Copied!");
              setTimeout(() => setButtonText("Increase"), 2000);
            })
            .catch((err) => {
              setButtonText("Copy Failed");
              setTimeout(() => setButtonText("Increase"), 2000);
            });
        };

        return h(
          "div",
          { class: "max-w-4xl mx-auto" },
          h(
            "div",
            { class: "flex justify-end mb-4" },
            h(
              "button",
              {
                onClick: increaseHeaders,
                class:
                  "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
              },
              buttonText
            )
          ),
          h("textarea", {
            ref: textareaRef,
            value: markdown,
            onInput: (e) => setMarkdown(e.target.value),
            class:
              "w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none",
            placeholder: "Enter your markdown here...",
          })
        );
      }

      render(h(App), document.getElementById("app"));
    </script>
  </body>
</html>
````

Changes made:

1. Removed the initial dummy text - the textarea now starts empty
2. Added clipboard copying functionality - when the button is clicked, it copies the updated markdown to clipboard and shows "Copied!" for 2 seconds before reverting to "Increase"
3. Added error handling for clipboard operations - shows "Copy Failed" if copying doesn't work

The app maintains all previous functionality while adding the copy feature and starting with a clean slate.

# a.3 (d)

<!--
2025.10.27 revert the change. fix focus
 -->

Act as an expert software engineer specializing in JavaScript and code quality. Your task is to analyze the provided JavaScript code, generate a detailed refactoring plan, AND output the complete refactored code.

**Follow this structured approach:**

**Phase 1: Analysis & Assessment**

1.  **Code Quality Scan:** Identify linting errors, formatting inconsistencies, and code smells.
2.  **Architectural Review:** Analyze function length, nesting depth, naming conventions, duplication, and coupling.
3.  **Test Status:** Note if tests exist and their likely coverage.

**Phase 2: Refactoring Plan**
Create a prioritized list of specific changes with clear justification:

- **Quick Wins** (formatting, simple syntax improvements)
- **Structural Improvements** (function extraction, conditional simplification)
- **Architectural Enhancements** (dependency injection, pattern application)

For each item, specify:

- **Problem:** What's wrong and why it matters
- **Solution:** How to fix it
- **Benefit:** Expected improvement

**Phase 3: Code Implementation**
After presenting the plan, provide the COMPLETE REFACTORED CODE that:

- Implements all suggested improvements
- Maintains the original functionality
- Includes clear comments for major changes
- Uses modern JavaScript (ES6+) best practices
- Has improved readability and maintainability

**Key Focus Areas:**

- ✅ Consistent formatting and style
- ✅ Descriptive naming conventions
- ✅ Simplified functions (single responsibility)
- ✅ Reduced nesting and cognitive complexity
- ✅ Eliminated code duplication
- ✅ Proper error handling
- ✅ Modern syntax (const/let, arrow functions, template literals, etc.)
- ✅ Better organization and exports

**Please refactor this JavaScript code:**

````javascript
const { h, render } = preact;
const { useState, useRef, useEffect } = preactHooks;

function App() {
  const [markdown, setMarkdown] = useState("");
  const [buttonText, setButtonText] = useState("Increase");
  const textareaRef = useRef(null);

  // Keep textarea focused
  useEffect(() => {
    const handleFocus = () => {
      if (textareaRef.current) {
        textareaRef.current.focus();
      }
    };

    // Initial focus
    handleFocus();

    // Focus on click anywhere
    document.addEventListener("click", handleFocus);

    return () => {
      document.removeEventListener("click", handleFocus);
    };
  }, []);

  const increaseHeaders = () => {
    const lines = markdown.split("\n");
    let inCodeBlock = false;
    const updatedLines = lines.map((line) => {
      // Toggle code block state
      if (line.trim().startsWith("```")) {
        inCodeBlock = !inCodeBlock;
        return line;
      }

      // Skip if we're in a code block
      if (inCodeBlock) return line;

      // Check if line is a header (starts with 1-6 # characters followed by space)
      const headerMatch = line.match(/^(#{1,6})\s(.*)/);
      if (headerMatch) {
        const hashes = headerMatch[1];
        const content = headerMatch[2];

        // Only increase if we're not already at the maximum (h6)
        if (hashes.length < 6) {
          return "#" + hashes + " " + content;
        }
      }

      return line;
    });

    const newMarkdown = updatedLines.join("\n");
    setMarkdown(newMarkdown);

    // Copy to clipboard
    navigator.clipboard
      .writeText(newMarkdown)
      .then(() => {
        setButtonText("Copied!");
        setTimeout(() => setButtonText("Increase"), 2000);
      })
      .catch((err) => {
        setButtonText("Copy Failed");
        setTimeout(() => setButtonText("Increase"), 2000);
      });
  };

  return h(
    "div",
    { class: "max-w-4xl mx-auto" },
    h(
      "div",
      { class: "flex justify-end mb-4" },
      h(
        "button",
        {
          onClick: increaseHeaders,
          class:
            "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
        },
        buttonText
      )
    ),
    h("textarea", {
      ref: textareaRef,
      value: markdown,
      onInput: (e) => setMarkdown(e.target.value),
      class:
        "w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none",
      placeholder: "Enter your markdown here...",
    })
  );
}

render(h(App), document.getElementById("app"));
````

**Output Format:**

1.  **Refactoring Plan** - Bulleted list of specific changes with explanations
2.  **Refactored Code** - Complete, runnable JavaScript code implementing all improvements

**Important:** Provide the FULL refactored code. Only reference unchanged sections if they exceed 200 lines.

---

## Refactoring Plan

### Phase 1: Analysis & Assessment

#### Code Quality Scan

- Mixed use of Preact's `h` function and modern hooks
- Inconsistent spacing in object literals
- Long function with multiple responsibilities
- Magic numbers (2000ms timeout)
- Missing error handling boundaries

#### Architectural Review

- `increaseHeaders` function violates Single Responsibility Principle (handles markdown processing, state updates, and clipboard operations)
- Deep nesting in markdown processing logic
- Event listener management could be cleaner
- No separation of concerns between UI and business logic

#### Test Status

- No tests provided or referenced
- Logic is tightly coupled to DOM APIs, making testing difficult

### Phase 2: Refactoring Plan

#### Quick Wins

1. **Formatting consistency**

   - Problem: Inconsistent spacing and object literal formatting
   - Solution: Apply consistent spacing and modern object shorthand
   - Benefit: Improved readability and maintainability

2. **Modern syntax adoption**
   - Problem: Using function declarations instead of arrow functions
   - Solution: Convert to arrow functions and use modern ES6+ features
   - Benefit: More consistent code style

#### Structural Improvements

3. **Extract markdown processing logic**

   - Problem: `increaseHeaders` does too much - processes markdown AND handles clipboard
   - Solution: Create pure function for markdown transformation
   - Benefit: Separated concerns, testable logic

4. **Simplify conditional logic**

   - Problem: Complex nested conditionals in markdown processing
   - Solution: Extract header transformation logic and use early returns
   - Benefit: Reduced cognitive complexity

5. **Extract clipboard handling**
   - Problem: Clipboard logic mixed with UI state updates
   - Solution: Create dedicated clipboard service function
   - Benefit: Reusable logic and better error handling

#### Architectural Enhancements

6. **Create custom hooks**

   - Problem: Focus management logic mixed with component
   - Solution: Extract `useAutoFocus` custom hook
   - Benefit: Reusable focus logic and cleaner component

7. **Separate UI components**
   - Problem: Monolithic component with mixed responsibilities
   - Solution: Extract Button and TextArea components
   - Benefit: Better component organization and reusability

### Phase 3: Code Implementation

````javascript
const { h, render } = preact;
const { useState, useRef, useEffect } = preactHooks;

/**
 * Custom hook for auto-focus functionality
 */
const useAutoFocus = (ref) => {
  useEffect(() => {
    const handleFocus = () => {
      if (ref.current) {
        ref.current.focus();
      }
    };

    // Initial focus
    handleFocus();

    // Focus on click anywhere
    document.addEventListener("click", handleFocus);

    return () => {
      document.removeEventListener("click", handleFocus);
    };
  }, [ref]);
};

/**
 * Pure function to increase markdown headers
 * @param {string} markdown - Original markdown content
 * @returns {string} - Transformed markdown with increased headers
 */
const increaseMarkdownHeaders = (markdown) => {
  const lines = markdown.split("\n");
  let inCodeBlock = false;

  return lines
    .map((line) => {
      // Handle code block boundaries
      if (line.trim().startsWith("```")) {
        inCodeBlock = !inCodeBlock;
        return line;
      }

      // Skip processing inside code blocks
      if (inCodeBlock) return line;

      // Process headers (starts with 1-6 # characters followed by space)
      const headerMatch = line.match(/^(#{1,6})\s(.*)/);
      if (!headerMatch) return line;

      const [_, hashes, content] = headerMatch;

      // Only increase if not already at maximum (h6)
      return hashes.length < 6 ? `#${hashes} ${content}` : line;
    })
    .join("\n");
};

/**
 * Service function to handle clipboard operations
 * @param {string} text - Text to copy to clipboard
 * @returns {Promise<void>}
 */
const copyToClipboard = async (text) => {
  try {
    await navigator.clipboard.writeText(text);
    return { success: true };
  } catch (error) {
    console.error("Failed to copy to clipboard:", error);
    return { success: false, error };
  }
};

/**
 * Button component with consistent styling
 */
const Button = ({ onClick, children, ...props }) =>
  h(
    "button",
    {
      onClick,
      class:
        "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
      ...props,
    },
    children
  );

/**
 * TextArea component with consistent styling
 */
const TextArea = ({ value, onInput, placeholder, ref, ...props }) =>
  h("textarea", {
    ref,
    value,
    onInput: (e) => onInput(e.target.value),
    class:
      "w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none",
    placeholder,
    ...props,
  });

/**
 * Main application component
 */
const App = () => {
  const [markdown, setMarkdown] = useState("");
  const [buttonText, setButtonText] = useState("Increase");
  const textareaRef = useRef(null);

  useAutoFocus(textareaRef);

  const handleIncreaseHeaders = async () => {
    const newMarkdown = increaseMarkdownHeaders(markdown);
    setMarkdown(newMarkdown);

    const { success } = await copyToClipboard(newMarkdown);

    const COPY_TIMEOUT = 2000;
    setButtonText(success ? "Copied!" : "Copy Failed");

    setTimeout(() => setButtonText("Increase"), COPY_TIMEOUT);
  };

  return h(
    "div",
    { class: "max-w-4xl mx-auto" },
    h(
      "div",
      { class: "flex justify-end mb-4" },
      h(Button, { onClick: handleIncreaseHeaders }, buttonText)
    ),
    h(TextArea, {
      ref: textareaRef,
      value: markdown,
      onInput: setMarkdown,
      placeholder: "Enter your markdown here...",
    })
  );
};

render(h(App), document.getElementById("app"));
````

### Key Improvements Made

1. **Separation of Concerns**: Business logic (markdown processing, clipboard operations) separated from UI logic
2. **Custom Hooks**: `useAutoFocus` encapsulates focus management logic
3. **Pure Functions**: `increaseMarkdownHeaders` is now testable and predictable
4. **Component Extraction**: Reusable Button and TextArea components
5. **Error Handling**: Better clipboard error handling with proper logging
6. **Modern Syntax**: Consistent use of arrow functions, template literals, and destructuring
7. **Constants**: Magic numbers replaced with named constants
8. **Reduced Complexity**: Simplified conditional logic and reduced nesting levels

The refactored code maintains all original functionality while being more maintainable, testable, and following modern JavaScript best practices.

# b

<!-- 2025.11.02 -->

**Role:** You are an expert programmer who follows plans precisely and implements complex programming tasks systematically.

**Current Code:**

````html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/hooks/dist/hooks.umd.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gray: {
                50: "#faf9f7",
                100: "#f5f4f2",
                200: "#e6e4e0",
                300: "#d6d3ce",
                400: "#a8a29e",
                500: "#78716c",
                600: "#57534e",
                700: "#44403c",
                800: "#292524",
                900: "#1c1917",
              },
            },
          },
        },
      };
    </script>
    <style>
      body {
        background-color: #1c1917;
        color: #f5f4f2;
      }
      textarea:focus {
        outline: none;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 font-sans">
    <div id="app"></div>

    <script type="module">
      const { h, render } = preact;
      const { useState, useRef, useEffect } = preactHooks;

      function App() {
        const [markdown, setMarkdown] = useState("");
        const [buttonText, setButtonText] = useState("Increase");
        const textareaRef = useRef(null);

        // Keep textarea focused
        useEffect(() => {
          const handleFocus = () => {
            if (textareaRef.current) {
              textareaRef.current.focus();
            }
          };

          // Initial focus
          handleFocus();

          // Focus on click anywhere
          document.addEventListener("click", handleFocus);

          return () => {
            document.removeEventListener("click", handleFocus);
          };
        }, []);

        const increaseHeaders = () => {
          const lines = markdown.split("\n");
          let inCodeBlock = false;
          const updatedLines = lines.map((line) => {
            // Toggle code block state
            if (line.trim().startsWith("```")) {
              inCodeBlock = !inCodeBlock;
              return line;
            }

            // Skip if we're in a code block
            if (inCodeBlock) return line;

            // Check if line is a header (starts with 1-6 # characters followed by space)
            const headerMatch = line.match(/^(#{1,6})\s(.*)/);
            if (headerMatch) {
              const hashes = headerMatch[1];
              const content = headerMatch[2];

              // Only increase if we're not already at the maximum (h6)
              if (hashes.length < 6) {
                return "#" + hashes + " " + content;
              }
            }

            return line;
          });

          const newMarkdown = updatedLines.join("\n");
          setMarkdown(newMarkdown);

          // Copy to clipboard
          navigator.clipboard
            .writeText(newMarkdown)
            .then(() => {
              setButtonText("Copied!");
              setTimeout(() => setButtonText("Increase"), 2000);
            })
            .catch((err) => {
              setButtonText("Copy Failed");
              setTimeout(() => setButtonText("Increase"), 2000);
            });
        };

        return h(
          "div",
          { class: "max-w-4xl mx-auto" },
          h(
            "div",
            { class: "flex justify-end mb-4" },
            h(
              "button",
              {
                onClick: increaseHeaders,
                class:
                  "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
              },
              buttonText
            )
          ),
          h("textarea", {
            ref: textareaRef,
            value: markdown,
            onInput: (e) => setMarkdown(e.target.value),
            class:
              "w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none",
            placeholder: "Enter your markdown here...",
          })
        );
      }

      render(h(App), document.getElementById("app"));
    </script>
  </body>
</html>
````

**Task Description:**

- add a decrease button, which removes `#` by 1. for header 1, it removes the `#`.

**Implementation Plan:**
[Provide your detailed, step-by-step plan here. For each step, include:]

1. **Specific step description** - What exactly needs to be done
2. **Approach choice** - Which method/algorithm to use from available options
3. **Technical details** - Specific libraries, patterns, or implementations
4. **Integration points** - How this connects to existing code

**Requirements:**

- Follow the plan exactly as specified
- If any part of the plan is ambiguous or requires clarification, ask me before proceeding
- Maintain code quality, readability, and existing functionality
- Include appropriate error handling and documentation
- Ensure backward compatibility unless specified otherwise

**Output Format:**

- Provide the complete, runnable updated code
- Only reference unchanged sections by name/description if they exceed 200 lines
- Include brief comments for major changes
- No preliminary explanations - just the code

**Ready for implementation.**

---

**Implementation Plan:**

1. **Add decrease button state**

   - Create new state variable `decreaseButtonText` initialized to "Decrease"
   - Use same state management pattern as existing increase button

2. **Implement decreaseHeaders function**

   - Copy same structure as increaseHeaders function
   - Modify logic to remove one `#` from headers instead of adding
   - Handle edge case where header has only one `#` (remove header entirely)
   - Maintain same code block detection logic
   - Use same clipboard copy functionality and feedback mechanism

3. **Update UI layout**

   - Change single button container to flex row with two buttons
   - Add margin between buttons for spacing
   - Maintain same styling for both buttons

4. **Integration with existing code**
   - Add new function alongside existing increaseHeaders
   - Insert new button in existing button container div
   - Preserve all existing functionality and focus behavior

**Complete Updated Code:**

````html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Markdown Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/preact/hooks/dist/hooks.umd.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gray: {
                50: "#faf9f7",
                100: "#f5f4f2",
                200: "#e6e4e0",
                300: "#d6d3ce",
                400: "#a8a29e",
                500: "#78716c",
                600: "#57534e",
                700: "#44403c",
                800: "#292524",
                900: "#1c1917",
              },
            },
          },
        },
      };
    </script>
    <style>
      body {
        background-color: #1c1917;
        color: #f5f4f2;
      }
      textarea:focus {
        outline: none;
      }
    </style>
  </head>
  <body class="min-h-screen p-4 font-sans">
    <div id="app"></div>

    <script type="module">
      const { h, render } = preact;
      const { useState, useRef, useEffect } = preactHooks;

      function App() {
        const [markdown, setMarkdown] = useState("");
        const [buttonText, setButtonText] = useState("Increase");
        const [decreaseButtonText, setDecreaseButtonText] =
          useState("Decrease");
        const textareaRef = useRef(null);

        // Keep textarea focused
        useEffect(() => {
          const handleFocus = () => {
            if (textareaRef.current) {
              textareaRef.current.focus();
            }
          };

          // Initial focus
          handleFocus();

          // Focus on click anywhere
          document.addEventListener("click", handleFocus);

          return () => {
            document.removeEventListener("click", handleFocus);
          };
        }, []);

        const increaseHeaders = () => {
          const lines = markdown.split("\n");
          let inCodeBlock = false;
          const updatedLines = lines.map((line) => {
            // Toggle code block state
            if (line.trim().startsWith("```")) {
              inCodeBlock = !inCodeBlock;
              return line;
            }

            // Skip if we're in a code block
            if (inCodeBlock) return line;

            // Check if line is a header (starts with 1-6 # characters followed by space)
            const headerMatch = line.match(/^(#{1,6})\s(.*)/);
            if (headerMatch) {
              const hashes = headerMatch[1];
              const content = headerMatch[2];

              // Only increase if we're not already at the maximum (h6)
              if (hashes.length < 6) {
                return "#" + hashes + " " + content;
              }
            }

            return line;
          });

          const newMarkdown = updatedLines.join("\n");
          setMarkdown(newMarkdown);

          // Copy to clipboard
          navigator.clipboard
            .writeText(newMarkdown)
            .then(() => {
              setButtonText("Copied!");
              setTimeout(() => setButtonText("Increase"), 2000);
            })
            .catch((err) => {
              setButtonText("Copy Failed");
              setTimeout(() => setButtonText("Increase"), 2000);
            });
        };

        const decreaseHeaders = () => {
          const lines = markdown.split("\n");
          let inCodeBlock = false;
          const updatedLines = lines.map((line) => {
            // Toggle code block state
            if (line.trim().startsWith("```")) {
              inCodeBlock = !inCodeBlock;
              return line;
            }

            // Skip if we're in a code block
            if (inCodeBlock) return line;

            // Check if line is a header (starts with 1-6 # characters followed by space)
            const headerMatch = line.match(/^(#{1,6})\s(.*)/);
            if (headerMatch) {
              const hashes = headerMatch[1];
              const content = headerMatch[2];

              // Remove one # or remove header entirely if it's only one #
              if (hashes.length === 1) {
                return content; // Remove header completely
              } else {
                return hashes.slice(1) + " " + content; // Remove one #
              }
            }

            return line;
          });

          const newMarkdown = updatedLines.join("\n");
          setMarkdown(newMarkdown);

          // Copy to clipboard
          navigator.clipboard
            .writeText(newMarkdown)
            .then(() => {
              setDecreaseButtonText("Copied!");
              setTimeout(() => setDecreaseButtonText("Decrease"), 2000);
            })
            .catch((err) => {
              setDecreaseButtonText("Copy Failed");
              setTimeout(() => setDecreaseButtonText("Decrease"), 2000);
            });
        };

        return h(
          "div",
          { class: "max-w-4xl mx-auto" },
          h(
            "div",
            { class: "flex justify-end gap-2 mb-4" },
            h(
              "button",
              {
                onClick: decreaseHeaders,
                class:
                  "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
              },
              decreaseButtonText
            ),
            h(
              "button",
              {
                onClick: increaseHeaders,
                class:
                  "px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-100 rounded transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-gray-500",
              },
              buttonText
            )
          ),
          h("textarea", {
            ref: textareaRef,
            value: markdown,
            onInput: (e) => setMarkdown(e.target.value),
            class:
              "w-full h-96 p-4 bg-gray-800 text-gray-100 rounded border border-gray-700 resize-none",
            placeholder: "Enter your markdown here...",
          })
        );
      }

      render(h(App), document.getElementById("app"));
    </script>
  </body>
</html>
````
