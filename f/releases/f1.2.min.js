const f={is:(r,t)=>null!=r&&("array"==t?Array.isArray(r):"function"==typeof t?r instanceof t:typeof r==t),has(r,...t){const{is:e}=f;if(!e(r,"object"))return!1;let n=r;for(const r of t){if(!Object.prototype.hasOwnProperty.call(n,r))return!1;n=n[r]}return!0},keys:r=>Object.keys(r),values:r=>Object.values(r),each:r=>Array.from({length:r+1},((r,t)=>t)),flatten(r,t){const{is:e,map:n}=f;let o={},s=r;for(;;){const r={};if(n(s,(([s,c])=>{"object"==typeof c?n(c,(([n,o])=>{""==n?r[s]=o:e(t,"string")?r[`${s}${t}${n}`]=o:e(t,"function")&&(r[t(s,n)]=o)})):o[s]=c})),s=r,0==Object.keys(s).length)break}return o},map(r,t){if(Array.isArray(r))return r.map(t);{const e=Object.entries(r).map(t);return e.every((r=>Array.isArray(r)&&r.length>=2))?Object.fromEntries(e):e}},generate:(r,t,e)=>Object.fromEntries(Array.from({length:e-t+1},((r,e)=>t+e)).map((t=>[t,r(t)]))),merge(r,t){const e=r=>"object"==typeof r&&null!==r,n=r=>{if(!e(r))return r;const t=Array.isArray(r)?[...r]:{...r},n=[{original:r,copy:t}];for(;n.length>0;){const{original:r,copy:t}=n.pop();for(const o in r)if(r.hasOwnProperty(o)){const s=r[o];if(e(s)){const r=Array.isArray(s)?[...s]:{...s};t[o]=r,n.push({original:s,copy:r})}}}return t},o=n(r);if(e(o)&&e(t)){const r=[{source:t,result:o}];for(;r.length>0;){const{source:t,result:o}=r.pop();for(const s in t)if(t.hasOwnProperty(s)){const c=t[s],a=o[s];o.hasOwnProperty(s)?e(a)&&e(c)&&r.push({source:c,result:a}):o[s]=n(c)}}}return o}};