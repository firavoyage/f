const f={is:(r,e)=>null!=r&&("array"==e?Array.isArray(r):"function"==typeof e?r instanceof e:typeof r==e),has(r,...e){const{is:t}=f;if(!t(r,"object"))return!1;let n=r;for(const r of e){if(!Object.prototype.hasOwnProperty.call(n,r))return!1;n=n[r]}return!0},keys:r=>Object.keys(r),values:r=>Object.values(r),each:r=>Array.from({length:r+1},((r,e)=>e)),flatten(r,e){const{is:t,map:n}=f;let a={},o=r;for(;;){const r={};if(n(o,(([o,s])=>{"object"==typeof s?n(s,(([n,a])=>{""==n?r[o]=a:t(e,"string")?r[`${o}${e}${n}`]=a:t(e,"function")&&(r[e(o,n)]=a)})):a[o]=s})),o=r,0==Object.keys(o).length)break}return a},map(r,e){if(Array.isArray(r))return r.map(e);{const t=Object.entries(r).map(e);return t.every((r=>Array.isArray(r)&&r.length>=2))?Object.fromEntries(t):t}},generate:(r,e,t)=>Object.fromEntries(Array.from({length:t-e+1},((r,t)=>e+t)).map((e=>[e,r(e)])))};